# DB 실전 이론 정리
### 현재 DB를 하는데 있어서 실제로 사용하게 되는 이론들에 대해서 정리 해둔 페이지이다.
&nbsp;

## Index

**인덱스(Index)** 는  <span style="color:yellow"> 데이터베이스의 테이블에 대한 검색 속도를 향상시켜주는 자료구조이다. </span>
테이블의 특정 컬럼(Column)에 인덱스를 생성하면, 해당 컬럼의 데이터를 정렬한 후 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된다. 
컬럼의 값과 물리적 주소를 (key, value)의 한 쌍으로 저장한다.

&nbsp;
인덱스는 책에서의 **목차** 혹은 **색인**이라고 생각하면 된다. 책에서 원하는 내용을 찾을 때 목차나 색인을 이용하면 훨씬 빠르게 찾을 수 있는데, 마찬가지로 테이블에서 원하는 데이터를 찾기 위해 인덱스를 이용하면 빠르게 찾을 수 있다. 
그러므로 데이터 = 책의 내용, 인덱스 = 책의 목차, 물리적 주소 = 책의 페이지 번호라고 생각할 수 있다. 

![index](https://user-images.githubusercontent.com/55444828/181892920-3542b07a-690d-4d81-87dd-203b02d3453d.png)

* 위의 그림과 같이 index로 설정된 column인 company_id = 18인 경우 index를 통해서 18 과 매칭된 pointer로 
곧바로 데이터로 접근이 가능하기 때문에 순차적인 탐색없이 제빠르게 접근이 가능


### <장점>

인덱스의 장점으로는 앞에서 말했듯이 테이블을 검색하는 속도와 성능이 향상된다. 또 그에 따라 시스템의 전반적인 부하를 줄일 수 있다. 
 
핵심은 인덱스에 의해 데이터들이 정렬된 형태를 갖는다는 것이다. 기존엔 Where문으로 특정 조건의 데이터를 찾기 위해서 테이블의 전체를 조건과 비교해야 하는 '풀 테이블 스캔(Full Table Scan)' 작업이 필요했는데, 인덱스를 이용하면 데이터들이 정렬되어 있기 때문에 조건에 맞는 데이터를 빠르게 찾을 수 있다. 
또 ORDER BY 문이나 MIN/MAX 같은 경우도 이미 정렬이 되어 있기 때문에 빠르게 수행할 수 있다. 
 
### <단점>

인덱스가 항상 정렬된 상태로 유지되어 오는 장점도 있지만, 그에 따른 여러 단점도 존재한다. 
 
1. 인덱스를 관리하기 위한 추가 작업이 필요
2. 추가 저장 공간 필요
3. 잘못 사용하는 경우 오히려 검색 성능 저하
 
인덱스를 항상 정렬된 상태로 유지해야 하기 때문에 인덱스가 적용된 컬럼에 삽입(INSERT), 삭제(DELETE), 수정(UPDATE) 작업을 수행하면 다음과 같은 추가 작업이 필요하다. 
 
- INSERT : 새로운 데이터에 대한 인덱스를 추가
- DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 수행
- UPDATE : 기존의 인덱스를 사용하지 않음 처리, 갱신된 데이터에 대한 인덱스 추가
 
이처럼 인덱스의 수정도 추가적으로 필요하기 때문에 데이터의 수정이 잦은 경우 성능이 낮아진다. 또 데이터의 인덱스를 제거하는 것이 아니라 '사용하지 않음'으로 처리하고 남겨두기 때문에 수정 작업이 많은 경우 실제 데이터에 비해 인덱스가 과도하게 커지는 문제점이 발생할 수 있다. 별도의 메모리 공간에 저장되기 때문에 추가 저장 공간이 많이 필요하게 된다. 
 
또한 인덱스는 전체 데이터의 10 ~ 15% 이상의 데이터를 처리하거나, 데이터의 형식에 따라 오히려 성능이 낮아질 수 있다. 예를 들어 나이나 성별과 같이 값의 range가 적은 컬럼인 경우, 인덱스를 읽고 나서 다시 많은 데이터를 조회해야 하기 때문에 비효율적이다. 

&nbsp;

### 사용하면 좋은 경우
인덱스를 효율적으로 사용하기 위해선 데이터의 range가 넓고 중복이 적을수록, 조회가 많거나 정렬된 상태가 유용한 컬럼에 사용하는 것이 좋다. 따라서 다음과 같은 경우들에 인덱스를 사용하면 효율적이다. 
 

규모가 큰 테이블
삽입(INSERT), 수정(UPDATE), 삭제(DELETE) 작업이 자주 발생하지 않는 컬럼
WHERE나 ORDER BY, JOIN 등이 자주 사용되는 컬럼
데이터의 중복도가 낮은 컬럼

&nbsp;

### 직접 겪은 사례

